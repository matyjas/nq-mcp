//! @generated
//! AUTO-GENERATED CODE - DO NOT EDIT!
//!
//! OpenAQ
//! Source: ../openapi/openapi/openaq-openapi.json
//! Version: 3.0.0
//! Generated by `oas3-gen v0.25.0`
//!
//! OpenAQ API

use super::types::*;
use anyhow::Context;
use reqwest::{Client, Url};
use validator::Validate;
pub const BASE_URL: &str = "https://example.com/";
#[derive(Debug, Clone)]
pub struct OpenAQClient {
    pub client: Client,
    pub base_url: Url,
}
impl Default for OpenAQClient {
    fn default() -> Self {
        Self::new()
    }
}
impl OpenAQClient {
    /// Create a client using the OpenAPI `servers[0]` URL.
    #[must_use]
    #[track_caller]
    pub fn new() -> Self {
        Self {
            client: Client::builder().build().expect("client"),
            base_url: Url::parse(BASE_URL).expect("valid base url"),
        }
    }
    /// Create a client with a custom base URL.
    pub fn with_base_url(base_url: impl AsRef<str>) -> anyhow::Result<Self> {
        Ok(Self {
            client: Client::builder()
                .build()
                .context("building reqwest client")?,
            base_url: Url::parse(base_url.as_ref()).context("parsing base url")?,
        })
    }
    /// Create a client from an existing `reqwest::Client`.
    pub fn with_client(base_url: impl AsRef<str>, client: Client) -> anyhow::Result<Self> {
        let url = Url::parse(base_url.as_ref()).context("parsing base url")?;
        Ok(Self {
            client,
            base_url: url,
        })
    }
    /// Get countries
    ///
    /// Provides a list of countries
    ///
    /// * Path: `GET /v3/countries`
    pub async fn countries_get_v3_countries(
        &self,
        request: CountriesGetV3CountriesRequest,
    ) -> anyhow::Result<CountriesGetV3CountriesResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("countries");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(CountriesGetV3CountriesRequest::parse_response(response).await?)
    }
    /// Get a country by ID
    ///
    /// Provides a country by country ID
    ///
    /// * Path: `GET /v3/countries/{countries_id}`
    pub async fn country_get_v3_countries_countries_id(
        &self,
        request: CountryGetV3CountriesCountriesIdRequest,
    ) -> anyhow::Result<CountriesGetV3CountriesResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("countries")
            .push(&request.path.countries_id.to_string());
        let response = self.client.get(url).send().await?;
        Ok(CountryGetV3CountriesCountriesIdRequest::parse_response(response).await?)
    }
    /// Get instruments
    ///
    /// Provides a list of instruments
    ///
    /// * Path: `GET /v3/instruments`
    pub async fn instruments_get_v3_instruments(
        &self,
        request: InstrumentsGetV3InstrumentsRequest,
    ) -> anyhow::Result<InstrumentsGetV3InstrumentsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("instruments");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(InstrumentsGetV3InstrumentsRequest::parse_response(response).await?)
    }
    /// Get an instrument by ID
    ///
    /// Provides a instrument by instrument ID
    ///
    /// * Path: `GET /v3/instruments/{instruments_id}`
    pub async fn instrument_get_v3_instruments_instruments_id(
        &self,
        request: InstrumentGetV3InstrumentsInstrumentsIdRequest,
    ) -> anyhow::Result<InstrumentsGetV3InstrumentsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("instruments")
            .push(&request.path.instruments_id.to_string());
        let response = self.client.get(url).send().await?;
        Ok(InstrumentGetV3InstrumentsInstrumentsIdRequest::parse_response(response).await?)
    }
    /// Get licenses
    ///
    /// Provides a list of licenses
    ///
    /// * Path: `GET /v3/licenses`
    pub async fn instruments_get_v3_licenses(
        &self,
        request: InstrumentsGetV3LicensesRequest,
    ) -> anyhow::Result<InstrumentsGetV3LicensesResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("licenses");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(InstrumentsGetV3LicensesRequest::parse_response(response).await?)
    }
    /// Get an instrument by ID
    ///
    /// Provides a instrument by instrument ID
    ///
    /// * Path: `GET /v3/licenses/{licenses_id}`
    pub async fn license_get_v3_licenses_licenses_id(
        &self,
        request: LicenseGetV3LicensesLicensesIdRequest,
    ) -> anyhow::Result<InstrumentsGetV3LicensesResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("licenses")
            .push(&request.path.licenses_id.to_string());
        let response = self.client.get(url).send().await?;
        Ok(LicenseGetV3LicensesLicensesIdRequest::parse_response(response).await?)
    }
    /// Get locations
    ///
    /// Provides a list of locations
    ///
    /// * Path: `GET /v3/locations`
    pub async fn locations_get_v3_locations(
        &self,
        request: LocationsGetV3LocationsRequest,
    ) -> anyhow::Result<LocationsGetV3LocationsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("locations");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(LocationsGetV3LocationsRequest::parse_response(response).await?)
    }
    /// Get a location by ID
    ///
    /// Provides a location by location ID
    ///
    /// * Path: `GET /v3/locations/{locations_id}`
    pub async fn location_get_v3_locations_locations_id(
        &self,
        request: LocationGetV3LocationsLocationsIdRequest,
    ) -> anyhow::Result<LocationsGetV3LocationsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("locations")
            .push(&request.path.locations_id.to_string());
        let response = self.client.get(url).send().await?;
        Ok(LocationGetV3LocationsLocationsIdRequest::parse_response(response).await?)
    }
    /// Get flags by location ID
    ///
    /// Provides a list of flags by location ID
    ///
    /// * Path: `GET /v3/locations/{locations_id}/flags`
    pub async fn location_flags_get_v3_locations_locations_id_flags(
        &self,
        request: LocationFlagsGetV3LocationsLocationsIdFlagsRequest,
    ) -> anyhow::Result<SensorFlagsGetV3SensorsSensorIdFlagsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("locations")
            .push(&request.path.locations_id.to_string())
            .push("flags");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(LocationFlagsGetV3LocationsLocationsIdFlagsRequest::parse_response(response).await?)
    }
    /// Get a location's latest measurements
    ///
    /// Providers a location's latest measurement values
    ///
    /// * Path: `GET /v3/locations/{locations_id}/latest`
    pub async fn location_latest_get_v3_locations_locations_id_latest(
        &self,
        request: LocationLatestGetV3LocationsLocationsIdLatestRequest,
    ) -> anyhow::Result<LocationLatestGetV3LocationsLocationsIdLatestResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("locations")
            .push(&request.path.locations_id.to_string())
            .push("latest");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(LocationLatestGetV3LocationsLocationsIdLatestRequest::parse_response(response).await?)
    }
    /// Get sensors by location ID
    ///
    /// Provides a list of sensors by location ID
    ///
    /// * Path: `GET /v3/locations/{locations_id}/sensors`
    pub async fn sensors_get_v3_locations_locations_id_sensors(
        &self,
        request: SensorsGetV3LocationsLocationsIdSensorsRequest,
    ) -> anyhow::Result<SensorGetV3SensorsSensorsIdResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("locations")
            .push(&request.path.locations_id.to_string())
            .push("sensors");
        let response = self.client.get(url).send().await?;
        Ok(SensorsGetV3LocationsLocationsIdSensorsRequest::parse_response(response).await?)
    }
    /// Get manufacturers
    ///
    /// Provides a list of manufacturers
    ///
    /// * Path: `GET /v3/manufacturers`
    pub async fn manufacturers_get_v3_manufacturers(
        &self,
        request: ManufacturersGetV3ManufacturersRequest,
    ) -> anyhow::Result<ManufacturersGetV3ManufacturersResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("manufacturers");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(ManufacturersGetV3ManufacturersRequest::parse_response(response).await?)
    }
    /// Get a manufacturer by ID
    ///
    /// Provides a manufacturer by manufacturer ID
    ///
    /// * Path: `GET /v3/manufacturers/{manufacturers_id}`
    pub async fn manufacturer_get_v3_manufacturers_manufacturers_id(
        &self,
        request: ManufacturerGetV3ManufacturersManufacturersIdRequest,
    ) -> anyhow::Result<ManufacturersGetV3ManufacturersResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("manufacturers")
            .push(&request.path.manufacturers_id.to_string());
        let response = self.client.get(url).send().await?;
        Ok(ManufacturerGetV3ManufacturersManufacturersIdRequest::parse_response(response).await?)
    }
    /// Get instruments by manufacturer ID
    ///
    /// Provides a list of instruments for a specific manufacturer
    ///
    /// * Path: `GET /v3/manufacturers/{manufacturers_id}/instruments`
    pub async fn get_instruments_by_manufacturer_v3_manufacturers_manufacturers_id_instruments(
        &self,
        request: GetInstrumentsByManufacturerV3ManufacturersManufacturersIdInstrumentsRequest,
    ) -> anyhow::Result<InstrumentsGetV3InstrumentsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("manufacturers")
            .push(&request.path.manufacturers_id.to_string())
            .push("instruments");
        let response = self.client.get(url).send().await?;
        Ok(
            GetInstrumentsByManufacturerV3ManufacturersManufacturersIdInstrumentsRequest::parse_response(
                    response,
                )
                .await?,
        )
    }
    /// Get owners
    ///
    /// Provides a list of owners
    ///
    /// * Path: `GET /v3/owners`
    pub async fn owners_get_v3_owners(
        &self,
        request: OwnersGetV3OwnersRequest,
    ) -> anyhow::Result<OwnersGetV3OwnersResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("owners");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(OwnersGetV3OwnersRequest::parse_response(response).await?)
    }
    /// Get a owner by ID
    ///
    /// Provides a owner by owner ID
    ///
    /// * Path: `GET /v3/owners/{owners_id}`
    pub async fn owner_get_v3_owners_owners_id(
        &self,
        request: OwnerGetV3OwnersOwnersIdRequest,
    ) -> anyhow::Result<OwnersGetV3OwnersResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("owners")
            .push(&request.path.owners_id.to_string());
        let response = self.client.get(url).send().await?;
        Ok(OwnerGetV3OwnersOwnersIdRequest::parse_response(response).await?)
    }
    /// Get a parameters
    ///
    /// Provides a list of parameters
    ///
    /// * Path: `GET /v3/parameters`
    pub async fn parameters_get_v3_parameters(
        &self,
        request: ParametersGetV3ParametersRequest,
    ) -> anyhow::Result<ParametersGetV3ParametersResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("parameters");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(ParametersGetV3ParametersRequest::parse_response(response).await?)
    }
    /// Get a parameter by ID
    ///
    /// Provides a parameter by parameter ID
    ///
    /// * Path: `GET /v3/parameters/{parameters_id}`
    pub async fn parameter_get_v3_parameters_parameters_id(
        &self,
        request: ParameterGetV3ParametersParametersIdRequest,
    ) -> anyhow::Result<ParametersGetV3ParametersResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("parameters")
            .push(&request.path.parameters_id.to_string());
        let response = self.client.get(url).send().await?;
        Ok(ParameterGetV3ParametersParametersIdRequest::parse_response(response).await?)
    }
    /// Parameters Latest Get
    ///
    /// * Path: `GET /v3/parameters/{parameters_id}/latest`
    pub async fn parameters_latest_get_v3_parameters_parameters_id_latest(
        &self,
        request: ParametersLatestGetV3ParametersParametersIdLatestRequest,
    ) -> anyhow::Result<LocationLatestGetV3LocationsLocationsIdLatestResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("parameters")
            .push(&request.path.parameters_id.to_string())
            .push("latest");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            ParametersLatestGetV3ParametersParametersIdLatestRequest::parse_response(response)
                .await?,
        )
    }
    /// Get providers
    ///
    /// Provides a list of providers
    ///
    /// * Path: `GET /v3/providers`
    pub async fn providers_get_v3_providers(
        &self,
        request: ProvidersGetV3ProvidersRequest,
    ) -> anyhow::Result<ProvidersGetV3ProvidersResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("providers");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(ProvidersGetV3ProvidersRequest::parse_response(response).await?)
    }
    /// Get a provider by ID
    ///
    /// Provides a provider by provider ID
    ///
    /// * Path: `GET /v3/providers/{providers_id}`
    pub async fn provider_get_v3_providers_providers_id(
        &self,
        request: ProviderGetV3ProvidersProvidersIdRequest,
    ) -> anyhow::Result<ProvidersGetV3ProvidersResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("providers")
            .push(&request.path.providers_id.to_string());
        let response = self.client.get(url).send().await?;
        Ok(ProviderGetV3ProvidersProvidersIdRequest::parse_response(response).await?)
    }
    /// Get flags by sensor ID
    ///
    /// Provides a list of flags by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensor_id}/flags`
    pub async fn sensor_flags_get_v3_sensors_sensor_id_flags(
        &self,
        request: SensorFlagsGetV3SensorsSensorIdFlagsRequest,
    ) -> anyhow::Result<SensorFlagsGetV3SensorsSensorIdFlagsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensor_id.to_string())
            .push("flags");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(SensorFlagsGetV3SensorsSensorIdFlagsRequest::parse_response(response).await?)
    }
    /// Get a sensor by ID
    ///
    /// Provides a sensor by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}`
    pub async fn sensor_get_v3_sensors_sensors_id(
        &self,
        request: SensorGetV3SensorsSensorsIdRequest,
    ) -> anyhow::Result<SensorGetV3SensorsSensorsIdResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string());
        let response = self.client.get(url).send().await?;
        Ok(SensorGetV3SensorsSensorsIdRequest::parse_response(response).await?)
    }
    /// Get measurements aggregated to day by sensor ID
    ///
    /// Provides a list of daily data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/days`
    pub async fn sensor_daily_get_v3_sensors_sensors_id_days(
        &self,
        request: SensorDailyGetV3SensorsSensorsIdDaysRequest,
    ) -> anyhow::Result<SensorDailyGetV3SensorsSensorsIdDaysResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("days");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(SensorDailyGetV3SensorsSensorsIdDaysRequest::parse_response(response).await?)
    }
    /// Get measurements aggregated from day to day of week by sensor ID
    ///
    /// Provides a list of yearly summaries of dayly data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/days/dayofweek`
    pub async fn sensor_daily_measurements_aggregate_to_dow_get_v3_sensors_sensors_id_days_dayofweek(
        &self,
        request: SensorDailyMeasurementsAggregateToDowGetV3SensorsSensorsIdDaysDayofweekRequest,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("days")
            .push("dayofweek");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorDailyMeasurementsAggregateToDowGetV3SensorsSensorsIdDaysDayofweekRequest::parse_response(
                    response,
                )
                .await?,
        )
    }
    /// Get measurements aggregated from hour to month by sensor ID
    ///
    /// Provides a list of daily summaries of hourly data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/days/monthly`
    pub async fn sensor_daily_aggregate_to_month_get_v3_sensors_sensors_id_days_monthly(
        &self,
        request: SensorDailyAggregateToMonthGetV3SensorsSensorsIdDaysMonthlyRequest,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("days")
            .push("monthly");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorDailyAggregateToMonthGetV3SensorsSensorsIdDaysMonthlyRequest::parse_response(
                response,
            )
            .await?,
        )
    }
    /// Get measurements aggregated from day to day of week by sensor ID
    ///
    /// Provides a list of yearly summaries of daily data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/days/monthofyear`
    pub async fn sensor_daily_measurements_aggregate_to_moy_get_v3_sensors_sensors_id_days_monthofyear(
        &self,
        request: SensorDailyMeasurementsAggregateToMoyGetV3SensorsSensorsIdDaysMonthofyearRequest,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("days")
            .push("monthofyear");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorDailyMeasurementsAggregateToMoyGetV3SensorsSensorsIdDaysMonthofyearRequest::parse_response(
                    response,
                )
                .await?,
        )
    }
    /// Get measurements aggregated from day to year by sensor ID
    ///
    /// Provides a list of yearly summaries of daily data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/days/yearly`
    pub async fn sensor_daily_aggregate_to_year_get_v3_sensors_sensors_id_days_yearly(
        &self,
        request: SensorDailyAggregateToYearGetV3SensorsSensorsIdDaysYearlyRequest,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("days")
            .push("yearly");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorDailyAggregateToYearGetV3SensorsSensorsIdDaysYearlyRequest::parse_response(
                response,
            )
            .await?,
        )
    }
    /// Get measurements aggregated to hour by sensor ID
    ///
    /// Provides a list of hourly data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/hours`
    pub async fn sensor_hourly_measurements_get_v3_sensors_sensors_id_hours(
        &self,
        request: SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursRequest,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("hours");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursRequest::parse_response(response)
                .await?,
        )
    }
    /// Get measurements aggregated from hour to day by sensor ID
    ///
    /// Provides a list of daily summaries of hourly data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/hours/daily`
    pub async fn sensor_hourly_measurements_aggregate_to_day_get_v3_sensors_sensors_id_hours_daily(
        &self,
        request: SensorHourlyMeasurementsAggregateToDayGetV3SensorsSensorsIdHoursDailyRequest,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("hours")
            .push("daily");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorHourlyMeasurementsAggregateToDayGetV3SensorsSensorsIdHoursDailyRequest::parse_response(
                    response,
                )
                .await?,
        )
    }
    /// Get measurements aggregated from hour to day of week by sensor ID
    ///
    /// Provides a list of yearly summaries of hourly data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/hours/dayofweek`
    pub async fn sensor_hourly_measurements_aggregate_to_dow_get_v3_sensors_sensors_id_hours_dayofweek(
        &self,
        request: SensorHourlyMeasurementsAggregateToDowGetV3SensorsSensorsIdHoursDayofweekRequest,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("hours")
            .push("dayofweek");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorHourlyMeasurementsAggregateToDowGetV3SensorsSensorsIdHoursDayofweekRequest::parse_response(
                    response,
                )
                .await?,
        )
    }
    /// Get measurements aggregated from hour to day of week by sensor ID
    ///
    /// Provides a list of yearly summaries of hourly data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/hours/hourofday`
    pub async fn sensor_hourly_measurements_aggregate_to_hod_get_v3_sensors_sensors_id_hours_hourofday(
        &self,
        request: SensorHourlyMeasurementsAggregateToHodGetV3SensorsSensorsIdHoursHourofdayRequest,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("hours")
            .push("hourofday");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorHourlyMeasurementsAggregateToHodGetV3SensorsSensorsIdHoursHourofdayRequest::parse_response(
                    response,
                )
                .await?,
        )
    }
    /// Get measurements aggregated from hour to month by sensor ID
    ///
    /// Provides a list of daily summaries of hourly data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/hours/monthly`
    pub async fn sensor_hourly_measurements_aggregate_to_month_get_v3_sensors_sensors_id_hours_monthly(
        &self,
        request: SensorHourlyMeasurementsAggregateToMonthGetV3SensorsSensorsIdHoursMonthlyRequest,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("hours")
            .push("monthly");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorHourlyMeasurementsAggregateToMonthGetV3SensorsSensorsIdHoursMonthlyRequest::parse_response(
                    response,
                )
                .await?,
        )
    }
    /// Get measurements aggregated from hour to day of week by sensor ID
    ///
    /// Provides a list of yearly summaries of hourly data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/hours/monthofyear`
    pub async fn sensor_hourly_measurements_aggregate_to_moy_get_v3_sensors_sensors_id_hours_monthofyear(
        &self,
        request: SensorHourlyMeasurementsAggregateToMoyGetV3SensorsSensorsIdHoursMonthofyearRequest,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("hours")
            .push("monthofyear");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorHourlyMeasurementsAggregateToMoyGetV3SensorsSensorsIdHoursMonthofyearRequest::parse_response(
                    response,
                )
                .await?,
        )
    }
    /// Get measurements aggregated from hour to year by sensor ID
    ///
    /// Provides a list of yearly summaries of hourly data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/hours/yearly`
    pub async fn sensor_hourly_measurements_aggregate_to_year_get_v3_sensors_sensors_id_hours_yearly(
        &self,
        request: SensorHourlyMeasurementsAggregateToYearGetV3SensorsSensorsIdHoursYearlyRequest,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("hours")
            .push("yearly");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorHourlyMeasurementsAggregateToYearGetV3SensorsSensorsIdHoursYearlyRequest::parse_response(
                    response,
                )
                .await?,
        )
    }
    /// Get measurements by sensor ID
    ///
    /// Provides a list of measurements by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/measurements`
    pub async fn sensor_measurements_get_v3_sensors_sensors_id_measurements(
        &self,
        request: SensorMeasurementsGetV3SensorsSensorsIdMeasurementsRequest,
    ) -> anyhow::Result<SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("measurements");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorMeasurementsGetV3SensorsSensorsIdMeasurementsRequest::parse_response(response)
                .await?,
        )
    }
    /// Get measurements aggregated to days by sensor ID
    ///
    /// Provides a list of measurements by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/measurements/daily`
    pub async fn sensor_measurements_aggregated_get_daily_v3_sensors_sensors_id_measurements_daily(
        &self,
        request: SensorMeasurementsAggregatedGetDailyV3SensorsSensorsIdMeasurementsDailyRequest,
    ) -> anyhow::Result<SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("measurements")
            .push("daily");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorMeasurementsAggregatedGetDailyV3SensorsSensorsIdMeasurementsDailyRequest::parse_response(
                    response,
                )
                .await?,
        )
    }
    /// Get measurements aggregated to hours by sensor ID
    ///
    /// Provides a list of measurements by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/measurements/hourly`
    pub async fn sensor_measurements_aggregated_get_hourly_v3_sensors_sensors_id_measurements_hourly(
        &self,
        request: SensorMeasurementsAggregatedGetHourlyV3SensorsSensorsIdMeasurementsHourlyRequest,
    ) -> anyhow::Result<SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("measurements")
            .push("hourly");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(
            SensorMeasurementsAggregatedGetHourlyV3SensorsSensorsIdMeasurementsHourlyRequest::parse_response(
                    response,
                )
                .await?,
        )
    }
    /// Get measurements aggregated to year by sensor ID
    ///
    /// Provides a list of annual data by sensor ID
    ///
    /// * Path: `GET /v3/sensors/{sensors_id}/years`
    pub async fn sensor_yearly_get_v3_sensors_sensors_id_years(
        &self,
        request: SensorYearlyGetV3SensorsSensorsIdYearsRequest,
    ) -> anyhow::Result<SensorYearlyGetV3SensorsSensorsIdYearsResponse> {
        request.validate().context("parameter validation")?;
        let mut url = self.base_url.clone();
        url.path_segments_mut()
            .map_err(|()| anyhow::anyhow!("URL cannot be a base"))?
            .push("v3")
            .push("sensors")
            .push(&request.path.sensors_id.to_string())
            .push("years");
        let response = self.client.get(url).query(&request.query).send().await?;
        Ok(SensorYearlyGetV3SensorsSensorsIdYearsRequest::parse_response(response).await?)
    }
}
