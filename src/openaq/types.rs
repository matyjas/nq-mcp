//!
//! AUTO-GENERATED CODE - DO NOT EDIT!
//!
//! OpenAQ
//! Source: ../openapi/openapi/openaq-openapi.json
//! Version: 3.0.0
//! Generated by `oas3-gen v0.25.0`
//!
//! OpenAQ API
// @generated
use serde::{Deserialize, Serialize};
use validator::Validate;
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct AnnualData {
    pub coordinates: Option<Coordinates>,
    pub coverage: Option<Coverage>,
    #[serde(rename = "flagInfo")]
    pub flag_info: FlagInfo,
    pub parameter: ParameterBase,
    pub period: Option<Period>,
    pub summary: Option<Summary>,
    pub value: Option<f64>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct AnnualDataResponse {
    pub meta: Option<Meta>,
    pub results: Vec<AnnualData>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct AttributionEntity {
    pub name: String,
    pub url: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub struct Coordinates {
    pub latitude: Option<f64>,
    pub longitude: Option<f64>,
}
/// Provides a list of countries
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct CountriesGetV3CountriesRequest {
    pub query: CountriesGetV3CountriesRequestQuery,
}
#[bon::bon]
impl CountriesGetV3CountriesRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        order_by: Option<serde_json::Value>,
        sort_order: Option<serde_json::Value>,
        providers_id: Option<serde_json::Value>,
        parameters_id: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            query: CountriesGetV3CountriesRequestQuery {
                order_by,
                sort_order,
                providers_id,
                parameters_id,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl CountriesGetV3CountriesRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<CountriesGetV3CountriesResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<CountriesResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(CountriesGetV3CountriesResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(CountriesGetV3CountriesResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(CountriesGetV3CountriesResponse::Unknown);
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct CountriesGetV3CountriesRequestQuery {
    /// The field by which to order results
    #[default(Some(Default::default()))]
    pub order_by: Option<serde_json::Value>,
    /// Sort results ascending or descending. Default ASC
    #[default(Some(Default::default()))]
    pub sort_order: Option<serde_json::Value>,
    /// Limit the results to a specific provider or multiple providers  with a single provider ID or a comma delimited list of IDs
    pub providers_id: Option<serde_json::Value>,
    pub parameters_id: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Response types for countries_get_v3_countries_get
#[derive(Debug, Clone)]
pub enum CountriesGetV3CountriesResponse {
    ///200: Successful Response
    Ok(CountriesResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct CountriesResponse {
    pub meta: Option<Meta>,
    pub results: Vec<Country>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum CountriesSortFields {
    #[serde(rename = "id")]
    #[default]
    Id,
}
impl core::fmt::Display for CountriesSortFields {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Id => write!(f, "id"),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Country {
    pub code: String,
    #[serde(rename = "datetimeFirst")]
    pub datetime_first: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(rename = "datetimeLast")]
    pub datetime_last: Option<chrono::DateTime<chrono::Utc>>,
    pub id: i64,
    pub name: String,
    pub parameters: Option<Vec<ParameterBase>>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct CountryBase {
    pub code: String,
    pub id: Option<i64>,
    pub name: String,
}
/// Provides a country by country ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct CountryGetV3CountriesCountriesIdRequest {
    #[validate(nested)]
    pub path: CountryGetV3CountriesCountriesIdRequestPath,
}
#[bon::bon]
impl CountryGetV3CountriesCountriesIdRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(countries_id: i64) -> anyhow::Result<Self> {
        let request = Self {
            path: CountryGetV3CountriesCountriesIdRequestPath { countries_id },
        };
        request.validate()?;
        Ok(request)
    }
}
impl CountryGetV3CountriesCountriesIdRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<CountriesGetV3CountriesResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<CountriesResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(CountriesGetV3CountriesResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(CountriesGetV3CountriesResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(CountriesGetV3CountriesResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, validator::Validate, oas3_gen_support::Default)]
pub struct CountryGetV3CountriesCountriesIdRequestPath {
    #[validate(range(min = 1i64))]
    pub countries_id: i64,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Coverage {
    #[serde(rename = "datetimeFrom")]
    pub datetime_from: Option<DatetimeObject>,
    #[serde(rename = "datetimeTo")]
    pub datetime_to: Option<DatetimeObject>,
    #[serde(rename = "expectedCount")]
    pub expected_count: i64,
    #[serde(rename = "expectedInterval")]
    pub expected_interval: String,
    #[serde(rename = "observedCount")]
    pub observed_count: i64,
    #[serde(rename = "observedInterval")]
    pub observed_interval: String,
    #[serde(rename = "percentComplete")]
    pub percent_complete: f64,
    #[serde(rename = "percentCoverage")]
    pub percent_coverage: f64,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct DailyData {
    pub coordinates: Option<Coordinates>,
    pub coverage: Option<Coverage>,
    #[serde(rename = "flagInfo")]
    pub flag_info: FlagInfo,
    pub parameter: ParameterBase,
    pub period: Option<Period>,
    pub summary: Option<Summary>,
    pub value: Option<f64>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct DailyDataResponse {
    pub meta: Option<Meta>,
    pub results: Vec<DailyData>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct DatetimeObject {
    pub local: chrono::DateTime<chrono::Utc>,
    pub utc: chrono::DateTime<chrono::Utc>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct EntityBase {
    pub id: i64,
    pub name: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct FlagInfo {
    #[serde(rename = "hasFlags")]
    pub has_flags: bool,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct FlagType {
    pub id: i64,
    pub label: String,
    pub level: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct GeoJSON {
    #[default(Some(Default::default()))]
    pub coordinates: Option<Vec<serde_json::Value>>,
    #[serde(rename = "type")]
    pub r#type: String,
}
/// Provides a list of instruments for a specific manufacturer
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetInstrumentsByManufacturerV3ManufacturersManufacturersIdInstrumentsRequest {
    pub path: GetInstrumentsByManufacturerV3ManufacturersManufacturersIdInstrumentsRequestPath,
}
#[bon::bon]
impl GetInstrumentsByManufacturerV3ManufacturersManufacturersIdInstrumentsRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(manufacturers_id: i64) -> anyhow::Result<Self> {
        let request = Self {
            path:
                GetInstrumentsByManufacturerV3ManufacturersManufacturersIdInstrumentsRequestPath {
                    manufacturers_id,
                },
        };
        request.validate()?;
        Ok(request)
    }
}
impl GetInstrumentsByManufacturerV3ManufacturersManufacturersIdInstrumentsRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<InstrumentsGetV3InstrumentsResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<InstrumentsResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(InstrumentsGetV3InstrumentsResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(InstrumentsGetV3InstrumentsResponse::UnprocessableEntity(
                data,
            ));
        }
        let _ = req.bytes().await?;
        return Ok(InstrumentsGetV3InstrumentsResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct GetInstrumentsByManufacturerV3ManufacturersManufacturersIdInstrumentsRequestPath {
    /// Limit results to a specific manufacturer id
    pub manufacturers_id: i64,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct HTTPValidationError {
    pub detail: Option<Vec<ValidationError>>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct HourlyData {
    pub coordinates: Option<Coordinates>,
    pub coverage: Option<Coverage>,
    #[serde(rename = "flagInfo")]
    pub flag_info: FlagInfo,
    pub parameter: ParameterBase,
    pub period: Option<Period>,
    pub summary: Option<Summary>,
    pub value: Option<f64>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct HourlyDataResponse {
    pub meta: Option<Meta>,
    pub results: Vec<HourlyData>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Instrument {
    pub id: i64,
    #[serde(rename = "isMonitor")]
    pub is_monitor: bool,
    pub manufacturer: ManufacturerBase,
    pub name: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct InstrumentBase {
    pub id: i64,
    pub name: String,
}
/// Provides a instrument by instrument ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct InstrumentGetV3InstrumentsInstrumentsIdRequest {
    pub path: InstrumentGetV3InstrumentsInstrumentsIdRequestPath,
}
#[bon::bon]
impl InstrumentGetV3InstrumentsInstrumentsIdRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(instruments_id: i64) -> anyhow::Result<Self> {
        let request = Self {
            path: InstrumentGetV3InstrumentsInstrumentsIdRequestPath { instruments_id },
        };
        request.validate()?;
        Ok(request)
    }
}
impl InstrumentGetV3InstrumentsInstrumentsIdRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<InstrumentsGetV3InstrumentsResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<InstrumentsResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(InstrumentsGetV3InstrumentsResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(InstrumentsGetV3InstrumentsResponse::UnprocessableEntity(
                data,
            ));
        }
        let _ = req.bytes().await?;
        return Ok(InstrumentsGetV3InstrumentsResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct InstrumentGetV3InstrumentsInstrumentsIdRequestPath {
    /// Limit the results to a specific instruments id
    pub instruments_id: i64,
}
/// Provides a list of instruments
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct InstrumentsGetV3InstrumentsRequest {
    pub query: InstrumentsGetV3InstrumentsRequestQuery,
}
#[bon::bon]
impl InstrumentsGetV3InstrumentsRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        order_by: Option<serde_json::Value>,
        sort_order: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            query: InstrumentsGetV3InstrumentsRequestQuery {
                order_by,
                sort_order,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl InstrumentsGetV3InstrumentsRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<InstrumentsGetV3InstrumentsResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<InstrumentsResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(InstrumentsGetV3InstrumentsResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(InstrumentsGetV3InstrumentsResponse::UnprocessableEntity(
                data,
            ));
        }
        let _ = req.bytes().await?;
        return Ok(InstrumentsGetV3InstrumentsResponse::Unknown);
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct InstrumentsGetV3InstrumentsRequestQuery {
    /// The field by which to order results
    #[default(Some(Default::default()))]
    pub order_by: Option<serde_json::Value>,
    /// Sort results ascending or descending. Default ASC
    #[default(Some(Default::default()))]
    pub sort_order: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Response types for instruments_get_v3_instruments_get
#[derive(Debug, Clone)]
pub enum InstrumentsGetV3InstrumentsResponse {
    ///200: Successful Response
    Ok(InstrumentsResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
/// Provides a list of licenses
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct InstrumentsGetV3LicensesRequest {
    pub query: InstrumentsGetV3LicensesRequestQuery,
}
#[bon::bon]
impl InstrumentsGetV3LicensesRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        order_by: Option<serde_json::Value>,
        sort_order: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            query: InstrumentsGetV3LicensesRequestQuery {
                order_by,
                sort_order,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl InstrumentsGetV3LicensesRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<InstrumentsGetV3LicensesResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<LicensesResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(InstrumentsGetV3LicensesResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(InstrumentsGetV3LicensesResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(InstrumentsGetV3LicensesResponse::Unknown);
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct InstrumentsGetV3LicensesRequestQuery {
    /// The field by which to order results
    #[default(Some(Default::default()))]
    pub order_by: Option<serde_json::Value>,
    /// Sort results ascending or descending. Default ASC
    #[default(Some(Default::default()))]
    pub sort_order: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Response types for instruments_get_v3_licenses_get
#[derive(Debug, Clone)]
pub enum InstrumentsGetV3LicensesResponse {
    ///200: Successful Response
    Ok(LicensesResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct InstrumentsResponse {
    pub meta: Option<Meta>,
    pub results: Vec<Instrument>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum InstrumentsSortFields {
    #[serde(rename = "id")]
    #[default]
    Id,
}
impl core::fmt::Display for InstrumentsSortFields {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Id => write!(f, "id"),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Latest {
    pub coordinates: Coordinates,
    pub datetime: DatetimeObject,
    #[serde(rename = "locationsId")]
    pub locations_id: i64,
    #[serde(rename = "sensorsId")]
    pub sensors_id: i64,
    pub value: f64,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct LatestBase {
    pub coordinates: Coordinates,
    pub datetime: DatetimeObject,
    pub value: f64,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct LatestResponse {
    pub meta: Option<Meta>,
    pub results: Vec<Latest>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct License {
    #[serde(rename = "attributionRequired")]
    pub attribution_required: bool,
    #[serde(rename = "commercialUseAllowed")]
    pub commercial_use_allowed: bool,
    pub id: i64,
    #[serde(rename = "modificationAllowed")]
    pub modification_allowed: bool,
    pub name: String,
    #[serde(rename = "redistributionAllowed")]
    pub redistribution_allowed: bool,
    #[serde(rename = "shareAlikeRequired")]
    pub share_alike_required: bool,
    #[serde(rename = "sourceUrl")]
    pub source_url: String,
}
/// Provides a instrument by instrument ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct LicenseGetV3LicensesLicensesIdRequest {
    pub path: LicenseGetV3LicensesLicensesIdRequestPath,
}
#[bon::bon]
impl LicenseGetV3LicensesLicensesIdRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(licenses_id: i64) -> anyhow::Result<Self> {
        let request = Self {
            path: LicenseGetV3LicensesLicensesIdRequestPath { licenses_id },
        };
        request.validate()?;
        Ok(request)
    }
}
impl LicenseGetV3LicensesLicensesIdRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<InstrumentsGetV3LicensesResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<LicensesResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(InstrumentsGetV3LicensesResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(InstrumentsGetV3LicensesResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(InstrumentsGetV3LicensesResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct LicenseGetV3LicensesLicensesIdRequestPath {
    /// Limit the results to a specific licenses id
    pub licenses_id: i64,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct LicensesResponse {
    pub meta: Option<Meta>,
    pub results: Vec<License>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum LicensesSortFields {
    #[serde(rename = "id")]
    #[default]
    Id,
}
impl core::fmt::Display for LicensesSortFields {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Id => write!(f, "id"),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum LocKind {
    #[default]
    String(String),
    Integer(i64),
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Location {
    pub bounds: Vec<f64>,
    pub coordinates: Coordinates,
    pub country: CountryBase,
    #[serde(rename = "datetimeFirst")]
    pub datetime_first: Option<DatetimeObject>,
    #[serde(rename = "datetimeLast")]
    pub datetime_last: Option<DatetimeObject>,
    pub distance: Option<f64>,
    pub id: i64,
    pub instruments: Vec<InstrumentBase>,
    #[serde(rename = "isMobile")]
    pub is_mobile: bool,
    #[serde(rename = "isMonitor")]
    pub is_monitor: bool,
    pub licenses: Option<Vec<LocationLicense>>,
    pub locality: Option<String>,
    pub name: Option<String>,
    pub owner: EntityBase,
    pub provider: ProviderBase,
    pub sensors: Vec<SensorBase>,
    pub timezone: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct LocationFlag {
    #[serde(rename = "datetimeFrom")]
    pub datetime_from: DatetimeObject,
    #[serde(rename = "datetimeTo")]
    pub datetime_to: DatetimeObject,
    #[serde(rename = "flagType")]
    pub flag_type: FlagType,
    #[serde(rename = "locationId")]
    pub location_id: i64,
    pub note: Option<String>,
    #[serde(rename = "sensorIds")]
    #[default(Some(Default::default()))]
    pub sensor_ids: Option<Vec<i64>>,
}
/// Provides a list of flags by location ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct LocationFlagsGetV3LocationsLocationsIdFlagsRequest {
    pub path: LocationFlagsGetV3LocationsLocationsIdFlagsRequestPath,
    pub query: LocationFlagsGetV3LocationsLocationsIdFlagsRequestQuery,
}
#[bon::bon]
impl LocationFlagsGetV3LocationsLocationsIdFlagsRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        locations_id: i64,
        limit: Option<i64>,
        page: Option<i64>,
        datetime_from: Option<serde_json::Value>,
        datetime_to: Option<serde_json::Value>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: LocationFlagsGetV3LocationsLocationsIdFlagsRequestPath { locations_id },
            query: LocationFlagsGetV3LocationsLocationsIdFlagsRequestQuery {
                limit,
                page,
                datetime_from,
                datetime_to,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl LocationFlagsGetV3LocationsLocationsIdFlagsRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorFlagsGetV3SensorsSensorIdFlagsResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<LocationFlagsResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorFlagsGetV3SensorsSensorIdFlagsResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorFlagsGetV3SensorsSensorIdFlagsResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(SensorFlagsGetV3SensorsSensorIdFlagsResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct LocationFlagsGetV3LocationsLocationsIdFlagsRequestPath {
    /// Limit the results to a specific locations
    pub locations_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct LocationFlagsGetV3LocationsLocationsIdFlagsRequestQuery {
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
    /// To when?
    pub datetime_from: Option<serde_json::Value>,
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct LocationFlagsResponse {
    pub meta: Option<Meta>,
    pub results: Vec<LocationFlag>,
}
/// Provides a location by location ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct LocationGetV3LocationsLocationsIdRequest {
    pub path: LocationGetV3LocationsLocationsIdRequestPath,
}
#[bon::bon]
impl LocationGetV3LocationsLocationsIdRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(locations_id: i64) -> anyhow::Result<Self> {
        let request = Self {
            path: LocationGetV3LocationsLocationsIdRequestPath { locations_id },
        };
        request.validate()?;
        Ok(request)
    }
}
impl LocationGetV3LocationsLocationsIdRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<LocationsGetV3LocationsResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<LocationsResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(LocationsGetV3LocationsResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(LocationsGetV3LocationsResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(LocationsGetV3LocationsResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct LocationGetV3LocationsLocationsIdRequestPath {
    /// Limit the results to a specific location by id
    pub locations_id: i64,
}
/// Providers a location's latest measurement values
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct LocationLatestGetV3LocationsLocationsIdLatestRequest {
    pub path: LocationLatestGetV3LocationsLocationsIdLatestRequestPath,
    pub query: LocationLatestGetV3LocationsLocationsIdLatestRequestQuery,
}
#[bon::bon]
impl LocationLatestGetV3LocationsLocationsIdLatestRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        locations_id: i64,
        limit: Option<i64>,
        page: Option<i64>,
        datetime_min: Option<serde_json::Value>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: LocationLatestGetV3LocationsLocationsIdLatestRequestPath { locations_id },
            query: LocationLatestGetV3LocationsLocationsIdLatestRequestQuery {
                limit,
                page,
                datetime_min,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl LocationLatestGetV3LocationsLocationsIdLatestRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<LocationLatestGetV3LocationsLocationsIdLatestResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<LatestResponse>::json_with_diagnostics(req).await?;
            return Ok(LocationLatestGetV3LocationsLocationsIdLatestResponse::Ok(
                data,
            ));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                LocationLatestGetV3LocationsLocationsIdLatestResponse::UnprocessableEntity(data),
            );
        }
        let _ = req.bytes().await?;
        return Ok(LocationLatestGetV3LocationsLocationsIdLatestResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct LocationLatestGetV3LocationsLocationsIdLatestRequestPath {
    /// Limit the results to a specific location by id
    pub locations_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct LocationLatestGetV3LocationsLocationsIdLatestRequestQuery {
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
    /// Minimum datetime
    pub datetime_min: Option<serde_json::Value>,
}
/// Response types for location_latest_get_v3_locations__locations_id__latest_get
#[derive(Debug, Clone)]
pub enum LocationLatestGetV3LocationsLocationsIdLatestResponse {
    ///200: Successful Response
    Ok(LatestResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct LocationLicense {
    pub attribution: AttributionEntity,
    #[serde(rename = "dateFrom")]
    pub date_from: Option<chrono::NaiveDate>,
    #[serde(rename = "dateTo")]
    pub date_to: Option<chrono::NaiveDate>,
    pub id: i64,
    pub name: String,
}
/// Provides a list of locations
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct LocationsGetV3LocationsRequest {
    pub query: LocationsGetV3LocationsRequestQuery,
}
#[bon::bon]
impl LocationsGetV3LocationsRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        coordinates: Option<Coordinates>,
        radius: Option<serde_json::Value>,
        providers_id: Option<serde_json::Value>,
        parameters_id: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
        owner_contacts_id: Option<serde_json::Value>,
        manufacturers_id: Option<serde_json::Value>,
        order_by: Option<serde_json::Value>,
        sort_order: Option<serde_json::Value>,
        licenses_id: Option<serde_json::Value>,
        monitor: Option<serde_json::Value>,
        mobile: Option<serde_json::Value>,
        instruments_id: Option<serde_json::Value>,
        iso: Option<serde_json::Value>,
        countries_id: Option<serde_json::Value>,
        bbox: Option<serde_json::Value>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            query: LocationsGetV3LocationsRequestQuery {
                coordinates,
                radius,
                providers_id,
                parameters_id,
                limit,
                page,
                owner_contacts_id,
                manufacturers_id,
                order_by,
                sort_order,
                licenses_id,
                monitor,
                mobile,
                instruments_id,
                iso,
                countries_id,
                bbox,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl LocationsGetV3LocationsRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<LocationsGetV3LocationsResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<LocationsResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(LocationsGetV3LocationsResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(LocationsGetV3LocationsResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(LocationsGetV3LocationsResponse::Unknown);
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct LocationsGetV3LocationsRequestQuery {
    /// WGS 84 Coordinate pair in form latitude,longitude. Supports up to 4 decimal points of precision, additional decimal precision will be truncated in the query e.g. 38.9074,-77.0373
    pub coordinates: Option<Coordinates>,
    /// Search radius from coordinates as center in meters. Maximum of 25,000 (25km) defaults to 1000 (1km) e.g. radius=1000
    pub radius: Option<serde_json::Value>,
    /// Limit the results to a specific provider or multiple providers  with a single provider ID or a comma delimited list of IDs
    pub providers_id: Option<serde_json::Value>,
    pub parameters_id: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
    /// Limit the results to a specific owner by owner ID with a single owner ID or comma delimited list of IDs
    pub owner_contacts_id: Option<serde_json::Value>,
    pub manufacturers_id: Option<serde_json::Value>,
    /// The field by which to order results
    #[default(Some(Default::default()))]
    pub order_by: Option<serde_json::Value>,
    /// Sort results ascending or descending. Default ASC
    #[default(Some(Default::default()))]
    pub sort_order: Option<serde_json::Value>,
    pub licenses_id: Option<serde_json::Value>,
    /// Is the location considered a reference monitor?
    pub monitor: Option<serde_json::Value>,
    /// Is the location considered a mobile location?
    pub mobile: Option<serde_json::Value>,
    pub instruments_id: Option<serde_json::Value>,
    /// Limit the results to a specific country using ISO 3166-1 alpha-2 code
    pub iso: Option<serde_json::Value>,
    /// Limit the results to a specific country or countries by country ID as a single country ID or a comma delimited list of IDs
    pub countries_id: Option<serde_json::Value>,
    /// geospatial bounding box of Min X, min Y, max X, max Y in WGS 84 coordinates. Up to 4 decimal points of precision, addtional decimal precision will be truncated to 4 decimal points precision e.g. -77.037,38.907,-77.0,39.910
    pub bbox: Option<serde_json::Value>,
}
/// Response types for locations_get_v3_locations_get
#[derive(Debug, Clone)]
pub enum LocationsGetV3LocationsResponse {
    ///200: Successful Response
    Ok(LocationsResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct LocationsResponse {
    pub meta: Option<Meta>,
    pub results: Vec<Location>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum LocationsSortFields {
    #[serde(rename = "id")]
    #[default]
    Id,
}
impl core::fmt::Display for LocationsSortFields {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Id => write!(f, "id"),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Manufacturer {
    pub id: i64,
    pub instruments: Vec<InstrumentBase>,
    pub name: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ManufacturerBase {
    pub id: i64,
    pub name: String,
}
/// Provides a manufacturer by manufacturer ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ManufacturerGetV3ManufacturersManufacturersIdRequest {
    pub path: ManufacturerGetV3ManufacturersManufacturersIdRequestPath,
}
#[bon::bon]
impl ManufacturerGetV3ManufacturersManufacturersIdRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(manufacturers_id: i64) -> anyhow::Result<Self> {
        let request = Self {
            path: ManufacturerGetV3ManufacturersManufacturersIdRequestPath { manufacturers_id },
        };
        request.validate()?;
        Ok(request)
    }
}
impl ManufacturerGetV3ManufacturersManufacturersIdRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<ManufacturersGetV3ManufacturersResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<ManufacturersResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(ManufacturersGetV3ManufacturersResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(ManufacturersGetV3ManufacturersResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(ManufacturersGetV3ManufacturersResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct ManufacturerGetV3ManufacturersManufacturersIdRequestPath {
    /// Limit the results to a specific manufacturers id
    pub manufacturers_id: i64,
}
/// Provides a list of manufacturers
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ManufacturersGetV3ManufacturersRequest {
    pub query: ManufacturersGetV3ManufacturersRequestQuery,
}
#[bon::bon]
impl ManufacturersGetV3ManufacturersRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        order_by: Option<serde_json::Value>,
        sort_order: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            query: ManufacturersGetV3ManufacturersRequestQuery {
                order_by,
                sort_order,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl ManufacturersGetV3ManufacturersRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<ManufacturersGetV3ManufacturersResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<ManufacturersResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(ManufacturersGetV3ManufacturersResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(ManufacturersGetV3ManufacturersResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(ManufacturersGetV3ManufacturersResponse::Unknown);
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct ManufacturersGetV3ManufacturersRequestQuery {
    /// The field by which to order results
    #[default(Some(Default::default()))]
    pub order_by: Option<serde_json::Value>,
    /// Sort results ascending or descending. Default ASC
    #[default(Some(Default::default()))]
    pub sort_order: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Response types for manufacturers_get_v3_manufacturers_get
#[derive(Debug, Clone)]
pub enum ManufacturersGetV3ManufacturersResponse {
    ///200: Successful Response
    Ok(ManufacturersResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ManufacturersResponse {
    pub meta: Option<Meta>,
    pub results: Vec<Manufacturer>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum ManufacturersSortFields {
    #[serde(rename = "id")]
    #[default]
    Id,
}
impl core::fmt::Display for ManufacturersSortFields {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Id => write!(f, "id"),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Measurement {
    pub coordinates: Option<Coordinates>,
    pub coverage: Option<Coverage>,
    #[serde(rename = "flagInfo")]
    pub flag_info: FlagInfo,
    pub parameter: ParameterBase,
    pub period: Option<Period>,
    pub summary: Option<Summary>,
    pub value: f64,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct MeasurementsResponse {
    pub meta: Option<Meta>,
    pub results: Vec<Measurement>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct Meta {
    pub found: Option<MetaFound>,
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    #[default(Some("openaq-api".to_string()))]
    pub name: Option<String>,
    #[default(Some(1i64))]
    pub page: Option<i64>,
    #[default(Some("/".to_string()))]
    pub website: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum MetaFound {
    #[default]
    Integer(i64),
    String(String),
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Owner {
    pub id: i64,
    pub name: String,
}
/// Provides a owner by owner ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct OwnerGetV3OwnersOwnersIdRequest {
    pub path: OwnerGetV3OwnersOwnersIdRequestPath,
}
#[bon::bon]
impl OwnerGetV3OwnersOwnersIdRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(owners_id: i64) -> anyhow::Result<Self> {
        let request = Self {
            path: OwnerGetV3OwnersOwnersIdRequestPath { owners_id },
        };
        request.validate()?;
        Ok(request)
    }
}
impl OwnerGetV3OwnersOwnersIdRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<OwnersGetV3OwnersResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<OwnersResponse>::json_with_diagnostics(req).await?;
            return Ok(OwnersGetV3OwnersResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(OwnersGetV3OwnersResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(OwnersGetV3OwnersResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct OwnerGetV3OwnersOwnersIdRequestPath {
    /// Limit the results to a specific owner by id
    pub owners_id: i64,
}
/// Provides a list of owners
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct OwnersGetV3OwnersRequest {
    pub query: OwnersGetV3OwnersRequestQuery,
}
#[bon::bon]
impl OwnersGetV3OwnersRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        order_by: Option<serde_json::Value>,
        sort_order: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            query: OwnersGetV3OwnersRequestQuery {
                order_by,
                sort_order,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl OwnersGetV3OwnersRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<OwnersGetV3OwnersResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<OwnersResponse>::json_with_diagnostics(req).await?;
            return Ok(OwnersGetV3OwnersResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(OwnersGetV3OwnersResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(OwnersGetV3OwnersResponse::Unknown);
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct OwnersGetV3OwnersRequestQuery {
    /// The field by which to order results
    #[default(Some(Default::default()))]
    pub order_by: Option<serde_json::Value>,
    /// Sort results ascending or descending. Default ASC
    #[default(Some(Default::default()))]
    pub sort_order: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Response types for owners_get_v3_owners_get
#[derive(Debug, Clone)]
pub enum OwnersGetV3OwnersResponse {
    ///200: Successful Response
    Ok(OwnersResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct OwnersResponse {
    pub meta: Option<Meta>,
    pub results: Vec<Owner>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum OwnersSortFields {
    #[serde(rename = "id")]
    #[default]
    Id,
}
impl core::fmt::Display for OwnersSortFields {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Id => write!(f, "id"),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Parameter {
    pub description: Option<String>,
    #[serde(rename = "displayName")]
    pub display_name: Option<String>,
    pub id: i64,
    pub name: String,
    pub units: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ParameterBase {
    #[serde(rename = "displayName")]
    pub display_name: Option<String>,
    pub id: i64,
    pub name: String,
    pub units: String,
}
/// Provides a parameter by parameter ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ParameterGetV3ParametersParametersIdRequest {
    pub path: ParameterGetV3ParametersParametersIdRequestPath,
}
#[bon::bon]
impl ParameterGetV3ParametersParametersIdRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(parameters_id: i64) -> anyhow::Result<Self> {
        let request = Self {
            path: ParameterGetV3ParametersParametersIdRequestPath { parameters_id },
        };
        request.validate()?;
        Ok(request)
    }
}
impl ParameterGetV3ParametersParametersIdRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<ParametersGetV3ParametersResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<ParametersResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(ParametersGetV3ParametersResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(ParametersGetV3ParametersResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(ParametersGetV3ParametersResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct ParameterGetV3ParametersParametersIdRequestPath {
    /// Limit the results to a specific parameters id
    pub parameters_id: i64,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum ParameterType {
    #[serde(rename = "pollutant")]
    #[default]
    Pollutant,
    #[serde(rename = "meteorological")]
    Meteorological,
}
impl core::fmt::Display for ParameterType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Pollutant => write!(f, "pollutant"),
            Self::Meteorological => write!(f, "meteorological"),
        }
    }
}
/// Provides a list of parameters
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ParametersGetV3ParametersRequest {
    pub query: ParametersGetV3ParametersRequestQuery,
}
#[bon::bon]
impl ParametersGetV3ParametersRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        order_by: Option<serde_json::Value>,
        sort_order: Option<serde_json::Value>,
        parameter_type: Option<serde_json::Value>,
        coordinates: Option<Coordinates>,
        radius: Option<serde_json::Value>,
        bbox: Option<serde_json::Value>,
        iso: Option<serde_json::Value>,
        countries_id: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            query: ParametersGetV3ParametersRequestQuery {
                order_by,
                sort_order,
                parameter_type,
                coordinates,
                radius,
                bbox,
                iso,
                countries_id,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl ParametersGetV3ParametersRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<ParametersGetV3ParametersResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<ParametersResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(ParametersGetV3ParametersResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(ParametersGetV3ParametersResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(ParametersGetV3ParametersResponse::Unknown);
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct ParametersGetV3ParametersRequestQuery {
    /// The field by which to order results
    #[default(Some(Default::default()))]
    pub order_by: Option<serde_json::Value>,
    /// Sort results ascending or descending. Default ASC
    #[default(Some(Default::default()))]
    pub sort_order: Option<serde_json::Value>,
    /// Limit the results to a specific parameters type
    pub parameter_type: Option<serde_json::Value>,
    /// WGS 84 Coordinate pair in form latitude,longitude. Supports up to 4 decimal points of precision, additional decimal precision will be truncated in the query e.g. 38.9074,-77.0373
    pub coordinates: Option<Coordinates>,
    /// Search radius from coordinates as center in meters. Maximum of 25,000 (25km) defaults to 1000 (1km) e.g. radius=1000
    pub radius: Option<serde_json::Value>,
    /// geospatial bounding box of Min X, min Y, max X, max Y in WGS 84 coordinates. Up to 4 decimal points of precision, addtional decimal precision will be truncated to 4 decimal points precision e.g. -77.037,38.907,-77.0,39.910
    pub bbox: Option<serde_json::Value>,
    /// Limit the results to a specific country using ISO 3166-1 alpha-2 code
    pub iso: Option<serde_json::Value>,
    /// Limit the results to a specific country or countries by country ID as a single country ID or a comma delimited list of IDs
    pub countries_id: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Response types for parameters_get_v3_parameters_get
#[derive(Debug, Clone)]
pub enum ParametersGetV3ParametersResponse {
    ///200: Successful Response
    Ok(ParametersResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
/// Parameters Latest Get
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ParametersLatestGetV3ParametersParametersIdLatestRequest {
    pub path: ParametersLatestGetV3ParametersParametersIdLatestRequestPath,
    pub query: ParametersLatestGetV3ParametersParametersIdLatestRequestQuery,
}
#[bon::bon]
impl ParametersLatestGetV3ParametersParametersIdLatestRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        parameters_id: i64,
        limit: Option<i64>,
        page: Option<i64>,
        datetime_min: Option<serde_json::Value>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: ParametersLatestGetV3ParametersParametersIdLatestRequestPath { parameters_id },
            query: ParametersLatestGetV3ParametersParametersIdLatestRequestQuery {
                limit,
                page,
                datetime_min,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl ParametersLatestGetV3ParametersParametersIdLatestRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<LocationLatestGetV3LocationsLocationsIdLatestResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<LatestResponse>::json_with_diagnostics(req).await?;
            return Ok(LocationLatestGetV3LocationsLocationsIdLatestResponse::Ok(
                data,
            ));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                LocationLatestGetV3LocationsLocationsIdLatestResponse::UnprocessableEntity(data),
            );
        }
        let _ = req.bytes().await?;
        return Ok(LocationLatestGetV3LocationsLocationsIdLatestResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct ParametersLatestGetV3ParametersParametersIdLatestRequestPath {
    /// Limit the results to a specific parameters id
    pub parameters_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct ParametersLatestGetV3ParametersParametersIdLatestRequestQuery {
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
    /// Minimum datetime
    pub datetime_min: Option<serde_json::Value>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ParametersResponse {
    pub meta: Option<Meta>,
    pub results: Vec<Parameter>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum ParametersSortFields {
    #[serde(rename = "id")]
    #[default]
    Id,
}
impl core::fmt::Display for ParametersSortFields {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Id => write!(f, "id"),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Period {
    #[serde(rename = "datetimeFrom")]
    pub datetime_from: Option<DatetimeObject>,
    #[serde(rename = "datetimeTo")]
    pub datetime_to: Option<DatetimeObject>,
    pub interval: String,
    pub label: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Provider {
    pub bbox: Option<GeoJSON>,
    #[serde(rename = "datetimeAdded")]
    pub datetime_added: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "datetimeFirst")]
    pub datetime_first: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "datetimeLast")]
    pub datetime_last: chrono::DateTime<chrono::Utc>,
    #[serde(rename = "entitiesId")]
    pub entities_id: i64,
    #[serde(rename = "exportPrefix")]
    pub export_prefix: String,
    pub id: i64,
    pub name: String,
    pub parameters: Vec<ParameterBase>,
    #[serde(rename = "sourceName")]
    pub source_name: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ProviderBase {
    pub id: i64,
    pub name: String,
}
/// Provides a provider by provider ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ProviderGetV3ProvidersProvidersIdRequest {
    pub path: ProviderGetV3ProvidersProvidersIdRequestPath,
}
#[bon::bon]
impl ProviderGetV3ProvidersProvidersIdRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(providers_id: i64) -> anyhow::Result<Self> {
        let request = Self {
            path: ProviderGetV3ProvidersProvidersIdRequestPath { providers_id },
        };
        request.validate()?;
        Ok(request)
    }
}
impl ProviderGetV3ProvidersProvidersIdRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<ProvidersGetV3ProvidersResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<ProvidersResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(ProvidersGetV3ProvidersResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(ProvidersGetV3ProvidersResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(ProvidersGetV3ProvidersResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct ProviderGetV3ProvidersProvidersIdRequestPath {
    /// Limit the results to a specific provider by id
    pub providers_id: i64,
}
/// Provides a list of providers
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ProvidersGetV3ProvidersRequest {
    pub query: ProvidersGetV3ProvidersRequestQuery,
}
#[bon::bon]
impl ProvidersGetV3ProvidersRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        order_by: Option<serde_json::Value>,
        sort_order: Option<serde_json::Value>,
        parameters_id: Option<serde_json::Value>,
        monitor: Option<serde_json::Value>,
        iso: Option<serde_json::Value>,
        countries_id: Option<serde_json::Value>,
        bbox: Option<serde_json::Value>,
        coordinates: Option<Coordinates>,
        radius: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            query: ProvidersGetV3ProvidersRequestQuery {
                order_by,
                sort_order,
                parameters_id,
                monitor,
                iso,
                countries_id,
                bbox,
                coordinates,
                radius,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl ProvidersGetV3ProvidersRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<ProvidersGetV3ProvidersResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<ProvidersResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(ProvidersGetV3ProvidersResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(ProvidersGetV3ProvidersResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(ProvidersGetV3ProvidersResponse::Unknown);
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct ProvidersGetV3ProvidersRequestQuery {
    /// The field by which to order results
    #[default(Some(Default::default()))]
    pub order_by: Option<serde_json::Value>,
    /// Sort results ascending or descending. Default ASC
    #[default(Some(Default::default()))]
    pub sort_order: Option<serde_json::Value>,
    pub parameters_id: Option<serde_json::Value>,
    /// Is the location considered a reference monitor?
    pub monitor: Option<serde_json::Value>,
    /// Limit the results to a specific country using ISO 3166-1 alpha-2 code
    pub iso: Option<serde_json::Value>,
    /// Limit the results to a specific country or countries by country ID as a single country ID or a comma delimited list of IDs
    pub countries_id: Option<serde_json::Value>,
    /// geospatial bounding box of Min X, min Y, max X, max Y in WGS 84 coordinates. Up to 4 decimal points of precision, addtional decimal precision will be truncated to 4 decimal points precision e.g. -77.037,38.907,-77.0,39.910
    pub bbox: Option<serde_json::Value>,
    /// WGS 84 Coordinate pair in form latitude,longitude. Supports up to 4 decimal points of precision, additional decimal precision will be truncated in the query e.g. 38.9074,-77.0373
    pub coordinates: Option<Coordinates>,
    /// Search radius from coordinates as center in meters. Maximum of 25,000 (25km) defaults to 1000 (1km) e.g. radius=1000
    pub radius: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Response types for providers_get_v3_providers_get
#[derive(Debug, Clone)]
pub enum ProvidersGetV3ProvidersResponse {
    ///200: Successful Response
    Ok(ProvidersResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ProvidersResponse {
    pub meta: Option<Meta>,
    pub results: Vec<Provider>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum ProvidersSortFields {
    #[serde(rename = "id")]
    #[default]
    Id,
}
impl core::fmt::Display for ProvidersSortFields {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Id => write!(f, "id"),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Sensor {
    pub coverage: Option<Coverage>,
    #[serde(rename = "datetimeFirst")]
    pub datetime_first: Option<DatetimeObject>,
    #[serde(rename = "datetimeLast")]
    pub datetime_last: Option<DatetimeObject>,
    pub id: i64,
    pub latest: Option<LatestBase>,
    pub name: String,
    pub parameter: ParameterBase,
    pub summary: Option<Summary>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct SensorBase {
    pub id: i64,
    pub name: String,
    pub parameter: ParameterBase,
}
/// Provides a list of daily summaries of hourly data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorDailyAggregateToMonthGetV3SensorsSensorsIdDaysMonthlyRequest {
    pub path: SensorDailyAggregateToMonthGetV3SensorsSensorsIdDaysMonthlyRequestPath,
    pub query: SensorDailyAggregateToMonthGetV3SensorsSensorsIdDaysMonthlyRequestQuery,
}
#[bon::bon]
impl SensorDailyAggregateToMonthGetV3SensorsSensorsIdDaysMonthlyRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        date_to: Option<serde_json::Value>,
        date_from: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorDailyAggregateToMonthGetV3SensorsSensorsIdDaysMonthlyRequestPath {
                sensors_id,
            },
            query: SensorDailyAggregateToMonthGetV3SensorsSensorsIdDaysMonthlyRequestQuery {
                date_to,
                date_from,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorDailyAggregateToMonthGetV3SensorsSensorsIdDaysMonthlyRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<HourlyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorDailyAggregateToMonthGetV3SensorsSensorsIdDaysMonthlyRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorDailyAggregateToMonthGetV3SensorsSensorsIdDaysMonthlyRequestQuery {
    /// To when?
    pub date_to: Option<serde_json::Value>,
    /// From when?
    pub date_from: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Provides a list of yearly summaries of daily data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorDailyAggregateToYearGetV3SensorsSensorsIdDaysYearlyRequest {
    pub path: SensorDailyAggregateToYearGetV3SensorsSensorsIdDaysYearlyRequestPath,
    pub query: SensorDailyAggregateToYearGetV3SensorsSensorsIdDaysYearlyRequestQuery,
}
#[bon::bon]
impl SensorDailyAggregateToYearGetV3SensorsSensorsIdDaysYearlyRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        date_to: Option<serde_json::Value>,
        date_from: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorDailyAggregateToYearGetV3SensorsSensorsIdDaysYearlyRequestPath {
                sensors_id,
            },
            query: SensorDailyAggregateToYearGetV3SensorsSensorsIdDaysYearlyRequestQuery {
                date_to,
                date_from,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorDailyAggregateToYearGetV3SensorsSensorsIdDaysYearlyRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<HourlyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorDailyAggregateToYearGetV3SensorsSensorsIdDaysYearlyRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorDailyAggregateToYearGetV3SensorsSensorsIdDaysYearlyRequestQuery {
    /// To when?
    pub date_to: Option<serde_json::Value>,
    /// From when?
    pub date_from: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Provides a list of daily data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorDailyGetV3SensorsSensorsIdDaysRequest {
    pub path: SensorDailyGetV3SensorsSensorsIdDaysRequestPath,
    pub query: SensorDailyGetV3SensorsSensorsIdDaysRequestQuery,
}
#[bon::bon]
impl SensorDailyGetV3SensorsSensorsIdDaysRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        date_to: Option<serde_json::Value>,
        date_from: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorDailyGetV3SensorsSensorsIdDaysRequestPath { sensors_id },
            query: SensorDailyGetV3SensorsSensorsIdDaysRequestQuery {
                date_to,
                date_from,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorDailyGetV3SensorsSensorsIdDaysRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorDailyGetV3SensorsSensorsIdDaysResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<DailyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorDailyGetV3SensorsSensorsIdDaysResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorDailyGetV3SensorsSensorsIdDaysResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(SensorDailyGetV3SensorsSensorsIdDaysResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorDailyGetV3SensorsSensorsIdDaysRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorDailyGetV3SensorsSensorsIdDaysRequestQuery {
    /// To when?
    pub date_to: Option<serde_json::Value>,
    /// From when?
    pub date_from: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Response types for sensor_daily_get_v3_sensors__sensors_id__days_get
#[derive(Debug, Clone)]
pub enum SensorDailyGetV3SensorsSensorsIdDaysResponse {
    ///200: Successful Response
    Ok(DailyDataResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
/// Provides a list of yearly summaries of dayly data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorDailyMeasurementsAggregateToDowGetV3SensorsSensorsIdDaysDayofweekRequest {
    pub path: SensorDailyMeasurementsAggregateToDowGetV3SensorsSensorsIdDaysDayofweekRequestPath,
    pub query: SensorDailyMeasurementsAggregateToDowGetV3SensorsSensorsIdDaysDayofweekRequestQuery,
}
#[bon::bon]
impl SensorDailyMeasurementsAggregateToDowGetV3SensorsSensorsIdDaysDayofweekRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        date_to: Option<serde_json::Value>,
        date_from: Option<serde_json::Value>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorDailyMeasurementsAggregateToDowGetV3SensorsSensorsIdDaysDayofweekRequestPath {
                sensors_id,
            },
            query: SensorDailyMeasurementsAggregateToDowGetV3SensorsSensorsIdDaysDayofweekRequestQuery {
                date_to,
                date_from,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorDailyMeasurementsAggregateToDowGetV3SensorsSensorsIdDaysDayofweekRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<HourlyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorDailyMeasurementsAggregateToDowGetV3SensorsSensorsIdDaysDayofweekRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorDailyMeasurementsAggregateToDowGetV3SensorsSensorsIdDaysDayofweekRequestQuery {
    /// To when?
    pub date_to: Option<serde_json::Value>,
    /// From when?
    pub date_from: Option<serde_json::Value>,
}
/// Provides a list of yearly summaries of daily data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorDailyMeasurementsAggregateToMoyGetV3SensorsSensorsIdDaysMonthofyearRequest {
    pub path: SensorDailyMeasurementsAggregateToMoyGetV3SensorsSensorsIdDaysMonthofyearRequestPath,
    pub query:
        SensorDailyMeasurementsAggregateToMoyGetV3SensorsSensorsIdDaysMonthofyearRequestQuery,
}
#[bon::bon]
impl SensorDailyMeasurementsAggregateToMoyGetV3SensorsSensorsIdDaysMonthofyearRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        date_to: Option<serde_json::Value>,
        date_from: Option<serde_json::Value>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorDailyMeasurementsAggregateToMoyGetV3SensorsSensorsIdDaysMonthofyearRequestPath {
                sensors_id,
            },
            query: SensorDailyMeasurementsAggregateToMoyGetV3SensorsSensorsIdDaysMonthofyearRequestQuery {
                date_to,
                date_from,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorDailyMeasurementsAggregateToMoyGetV3SensorsSensorsIdDaysMonthofyearRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<HourlyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorDailyMeasurementsAggregateToMoyGetV3SensorsSensorsIdDaysMonthofyearRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorDailyMeasurementsAggregateToMoyGetV3SensorsSensorsIdDaysMonthofyearRequestQuery {
    /// To when?
    pub date_to: Option<serde_json::Value>,
    /// From when?
    pub date_from: Option<serde_json::Value>,
}
/// Provides a list of flags by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorFlagsGetV3SensorsSensorIdFlagsRequest {
    pub path: SensorFlagsGetV3SensorsSensorIdFlagsRequestPath,
    pub query: SensorFlagsGetV3SensorsSensorIdFlagsRequestQuery,
}
#[bon::bon]
impl SensorFlagsGetV3SensorsSensorIdFlagsRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensor_id: i64,
        limit: Option<i64>,
        page: Option<i64>,
        datetime_from: Option<serde_json::Value>,
        datetime_to: Option<serde_json::Value>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorFlagsGetV3SensorsSensorIdFlagsRequestPath { sensor_id },
            query: SensorFlagsGetV3SensorsSensorIdFlagsRequestQuery {
                limit,
                page,
                datetime_from,
                datetime_to,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorFlagsGetV3SensorsSensorIdFlagsRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorFlagsGetV3SensorsSensorIdFlagsResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<LocationFlagsResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorFlagsGetV3SensorsSensorIdFlagsResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorFlagsGetV3SensorsSensorIdFlagsResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(SensorFlagsGetV3SensorsSensorIdFlagsResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorFlagsGetV3SensorsSensorIdFlagsRequestPath {
    /// Limit the results to a specific sensor
    pub sensor_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorFlagsGetV3SensorsSensorIdFlagsRequestQuery {
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
    /// To when?
    pub datetime_from: Option<serde_json::Value>,
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
}
/// Response types for sensor_flags_get_v3_sensors__sensor_id__flags_get
#[derive(Debug, Clone)]
pub enum SensorFlagsGetV3SensorsSensorIdFlagsResponse {
    ///200: Successful Response
    Ok(LocationFlagsResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
/// Provides a sensor by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorGetV3SensorsSensorsIdRequest {
    pub path: SensorGetV3SensorsSensorsIdRequestPath,
}
#[bon::bon]
impl SensorGetV3SensorsSensorsIdRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(sensors_id: i64) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorGetV3SensorsSensorsIdRequestPath { sensors_id },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorGetV3SensorsSensorsIdRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorGetV3SensorsSensorsIdResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data = oas3_gen_support::Diagnostics::<SensorsResponse>::json_with_diagnostics(req)
                .await?;
            return Ok(SensorGetV3SensorsSensorsIdResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorGetV3SensorsSensorsIdResponse::UnprocessableEntity(
                data,
            ));
        }
        let _ = req.bytes().await?;
        return Ok(SensorGetV3SensorsSensorsIdResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorGetV3SensorsSensorsIdRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
/// Response types for sensor_get_v3_sensors__sensors_id__get
#[derive(Debug, Clone)]
pub enum SensorGetV3SensorsSensorsIdResponse {
    ///200: Successful Response
    Ok(SensorsResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
/// Provides a list of daily summaries of hourly data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToDayGetV3SensorsSensorsIdHoursDailyRequest {
    pub path: SensorHourlyMeasurementsAggregateToDayGetV3SensorsSensorsIdHoursDailyRequestPath,
    pub query: SensorHourlyMeasurementsAggregateToDayGetV3SensorsSensorsIdHoursDailyRequestQuery,
}
#[bon::bon]
impl SensorHourlyMeasurementsAggregateToDayGetV3SensorsSensorsIdHoursDailyRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        datetime_to: Option<serde_json::Value>,
        datetime_from: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path:
                SensorHourlyMeasurementsAggregateToDayGetV3SensorsSensorsIdHoursDailyRequestPath {
                    sensors_id,
                },
            query:
                SensorHourlyMeasurementsAggregateToDayGetV3SensorsSensorsIdHoursDailyRequestQuery {
                    datetime_to,
                    datetime_from,
                    limit,
                    page,
                },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorHourlyMeasurementsAggregateToDayGetV3SensorsSensorsIdHoursDailyRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<HourlyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToDayGetV3SensorsSensorsIdHoursDailyRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToDayGetV3SensorsSensorsIdHoursDailyRequestQuery {
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
    /// From when?
    pub datetime_from: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Provides a list of yearly summaries of hourly data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToDowGetV3SensorsSensorsIdHoursDayofweekRequest {
    pub path: SensorHourlyMeasurementsAggregateToDowGetV3SensorsSensorsIdHoursDayofweekRequestPath,
    pub query:
        SensorHourlyMeasurementsAggregateToDowGetV3SensorsSensorsIdHoursDayofweekRequestQuery,
}
#[bon::bon]
impl SensorHourlyMeasurementsAggregateToDowGetV3SensorsSensorsIdHoursDayofweekRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        datetime_to: Option<serde_json::Value>,
        datetime_from: Option<serde_json::Value>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorHourlyMeasurementsAggregateToDowGetV3SensorsSensorsIdHoursDayofweekRequestPath {
                sensors_id,
            },
            query: SensorHourlyMeasurementsAggregateToDowGetV3SensorsSensorsIdHoursDayofweekRequestQuery {
                datetime_to,
                datetime_from,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorHourlyMeasurementsAggregateToDowGetV3SensorsSensorsIdHoursDayofweekRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<HourlyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToDowGetV3SensorsSensorsIdHoursDayofweekRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToDowGetV3SensorsSensorsIdHoursDayofweekRequestQuery {
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
    /// From when?
    pub datetime_from: Option<serde_json::Value>,
}
/// Provides a list of yearly summaries of hourly data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToHodGetV3SensorsSensorsIdHoursHourofdayRequest {
    pub path: SensorHourlyMeasurementsAggregateToHodGetV3SensorsSensorsIdHoursHourofdayRequestPath,
    pub query:
        SensorHourlyMeasurementsAggregateToHodGetV3SensorsSensorsIdHoursHourofdayRequestQuery,
}
#[bon::bon]
impl SensorHourlyMeasurementsAggregateToHodGetV3SensorsSensorsIdHoursHourofdayRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        datetime_to: Option<serde_json::Value>,
        datetime_from: Option<serde_json::Value>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorHourlyMeasurementsAggregateToHodGetV3SensorsSensorsIdHoursHourofdayRequestPath {
                sensors_id,
            },
            query: SensorHourlyMeasurementsAggregateToHodGetV3SensorsSensorsIdHoursHourofdayRequestQuery {
                datetime_to,
                datetime_from,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorHourlyMeasurementsAggregateToHodGetV3SensorsSensorsIdHoursHourofdayRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<HourlyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToHodGetV3SensorsSensorsIdHoursHourofdayRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToHodGetV3SensorsSensorsIdHoursHourofdayRequestQuery {
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
    /// From when?
    pub datetime_from: Option<serde_json::Value>,
}
/// Provides a list of daily summaries of hourly data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToMonthGetV3SensorsSensorsIdHoursMonthlyRequest {
    pub path: SensorHourlyMeasurementsAggregateToMonthGetV3SensorsSensorsIdHoursMonthlyRequestPath,
    pub query:
        SensorHourlyMeasurementsAggregateToMonthGetV3SensorsSensorsIdHoursMonthlyRequestQuery,
}
#[bon::bon]
impl SensorHourlyMeasurementsAggregateToMonthGetV3SensorsSensorsIdHoursMonthlyRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        datetime_to: Option<serde_json::Value>,
        datetime_from: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorHourlyMeasurementsAggregateToMonthGetV3SensorsSensorsIdHoursMonthlyRequestPath {
                sensors_id,
            },
            query: SensorHourlyMeasurementsAggregateToMonthGetV3SensorsSensorsIdHoursMonthlyRequestQuery {
                datetime_to,
                datetime_from,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorHourlyMeasurementsAggregateToMonthGetV3SensorsSensorsIdHoursMonthlyRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<HourlyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToMonthGetV3SensorsSensorsIdHoursMonthlyRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToMonthGetV3SensorsSensorsIdHoursMonthlyRequestQuery {
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
    /// From when?
    pub datetime_from: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Provides a list of yearly summaries of hourly data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToMoyGetV3SensorsSensorsIdHoursMonthofyearRequest {
    pub path:
        SensorHourlyMeasurementsAggregateToMoyGetV3SensorsSensorsIdHoursMonthofyearRequestPath,
    pub query:
        SensorHourlyMeasurementsAggregateToMoyGetV3SensorsSensorsIdHoursMonthofyearRequestQuery,
}
#[bon::bon]
impl SensorHourlyMeasurementsAggregateToMoyGetV3SensorsSensorsIdHoursMonthofyearRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        datetime_to: Option<serde_json::Value>,
        datetime_from: Option<serde_json::Value>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorHourlyMeasurementsAggregateToMoyGetV3SensorsSensorsIdHoursMonthofyearRequestPath {
                sensors_id,
            },
            query: SensorHourlyMeasurementsAggregateToMoyGetV3SensorsSensorsIdHoursMonthofyearRequestQuery {
                datetime_to,
                datetime_from,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorHourlyMeasurementsAggregateToMoyGetV3SensorsSensorsIdHoursMonthofyearRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<HourlyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToMoyGetV3SensorsSensorsIdHoursMonthofyearRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToMoyGetV3SensorsSensorsIdHoursMonthofyearRequestQuery {
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
    /// From when?
    pub datetime_from: Option<serde_json::Value>,
}
/// Provides a list of yearly summaries of hourly data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToYearGetV3SensorsSensorsIdHoursYearlyRequest {
    pub path: SensorHourlyMeasurementsAggregateToYearGetV3SensorsSensorsIdHoursYearlyRequestPath,
    pub query: SensorHourlyMeasurementsAggregateToYearGetV3SensorsSensorsIdHoursYearlyRequestQuery,
}
#[bon::bon]
impl SensorHourlyMeasurementsAggregateToYearGetV3SensorsSensorsIdHoursYearlyRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        datetime_to: Option<serde_json::Value>,
        datetime_from: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorHourlyMeasurementsAggregateToYearGetV3SensorsSensorsIdHoursYearlyRequestPath {
                sensors_id,
            },
            query: SensorHourlyMeasurementsAggregateToYearGetV3SensorsSensorsIdHoursYearlyRequestQuery {
                datetime_to,
                datetime_from,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorHourlyMeasurementsAggregateToYearGetV3SensorsSensorsIdHoursYearlyRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<HourlyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToYearGetV3SensorsSensorsIdHoursYearlyRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsAggregateToYearGetV3SensorsSensorsIdHoursYearlyRequestQuery {
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
    /// From when?
    pub datetime_from: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Provides a list of hourly data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursRequest {
    pub path: SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursRequestPath,
    pub query: SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursRequestQuery,
}
#[bon::bon]
impl SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        datetime_to: Option<serde_json::Value>,
        datetime_from: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursRequestPath { sensors_id },
            query: SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursRequestQuery {
                datetime_to,
                datetime_from,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<HourlyDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursRequestQuery {
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
    /// From when?
    pub datetime_from: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Response types for sensor_hourly_measurements_get_v3_sensors__sensors_id__hours_get
#[derive(Debug, Clone)]
pub enum SensorHourlyMeasurementsGetV3SensorsSensorsIdHoursResponse {
    ///200: Successful Response
    Ok(HourlyDataResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
/// Provides a list of measurements by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorMeasurementsAggregatedGetDailyV3SensorsSensorsIdMeasurementsDailyRequest {
    pub path: SensorMeasurementsAggregatedGetDailyV3SensorsSensorsIdMeasurementsDailyRequestPath,
    pub query: SensorMeasurementsAggregatedGetDailyV3SensorsSensorsIdMeasurementsDailyRequestQuery,
}
#[bon::bon]
impl SensorMeasurementsAggregatedGetDailyV3SensorsSensorsIdMeasurementsDailyRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        datetime_to: Option<serde_json::Value>,
        datetime_from: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorMeasurementsAggregatedGetDailyV3SensorsSensorsIdMeasurementsDailyRequestPath {
                sensors_id,
            },
            query: SensorMeasurementsAggregatedGetDailyV3SensorsSensorsIdMeasurementsDailyRequestQuery {
                datetime_to,
                datetime_from,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorMeasurementsAggregatedGetDailyV3SensorsSensorsIdMeasurementsDailyRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<MeasurementsResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorMeasurementsAggregatedGetDailyV3SensorsSensorsIdMeasurementsDailyRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorMeasurementsAggregatedGetDailyV3SensorsSensorsIdMeasurementsDailyRequestQuery {
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
    /// From when?
    pub datetime_from: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Provides a list of measurements by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorMeasurementsAggregatedGetHourlyV3SensorsSensorsIdMeasurementsHourlyRequest {
    pub path: SensorMeasurementsAggregatedGetHourlyV3SensorsSensorsIdMeasurementsHourlyRequestPath,
    pub query:
        SensorMeasurementsAggregatedGetHourlyV3SensorsSensorsIdMeasurementsHourlyRequestQuery,
}
#[bon::bon]
impl SensorMeasurementsAggregatedGetHourlyV3SensorsSensorsIdMeasurementsHourlyRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        datetime_to: Option<serde_json::Value>,
        datetime_from: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorMeasurementsAggregatedGetHourlyV3SensorsSensorsIdMeasurementsHourlyRequestPath {
                sensors_id,
            },
            query: SensorMeasurementsAggregatedGetHourlyV3SensorsSensorsIdMeasurementsHourlyRequestQuery {
                datetime_to,
                datetime_from,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorMeasurementsAggregatedGetHourlyV3SensorsSensorsIdMeasurementsHourlyRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<MeasurementsResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorMeasurementsAggregatedGetHourlyV3SensorsSensorsIdMeasurementsHourlyRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorMeasurementsAggregatedGetHourlyV3SensorsSensorsIdMeasurementsHourlyRequestQuery {
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
    /// From when?
    pub datetime_from: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Provides a list of measurements by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorMeasurementsGetV3SensorsSensorsIdMeasurementsRequest {
    pub path: SensorMeasurementsGetV3SensorsSensorsIdMeasurementsRequestPath,
    pub query: SensorMeasurementsGetV3SensorsSensorsIdMeasurementsRequestQuery,
}
#[bon::bon]
impl SensorMeasurementsGetV3SensorsSensorsIdMeasurementsRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        datetime_to: Option<serde_json::Value>,
        datetime_from: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorMeasurementsGetV3SensorsSensorsIdMeasurementsRequestPath { sensors_id },
            query: SensorMeasurementsGetV3SensorsSensorsIdMeasurementsRequestQuery {
                datetime_to,
                datetime_from,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorMeasurementsGetV3SensorsSensorsIdMeasurementsRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<MeasurementsResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(
                SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse::UnprocessableEntity(
                    data,
                ),
            );
        }
        let _ = req.bytes().await?;
        return Ok(SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorMeasurementsGetV3SensorsSensorsIdMeasurementsRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorMeasurementsGetV3SensorsSensorsIdMeasurementsRequestQuery {
    /// To when?
    pub datetime_to: Option<serde_json::Value>,
    /// From when?
    pub datetime_from: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Response types for sensor_measurements_get_v3_sensors__sensors_id__measurements_get
#[derive(Debug, Clone)]
pub enum SensorMeasurementsGetV3SensorsSensorsIdMeasurementsResponse {
    ///200: Successful Response
    Ok(MeasurementsResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
/// Provides a list of annual data by sensor ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorYearlyGetV3SensorsSensorsIdYearsRequest {
    pub path: SensorYearlyGetV3SensorsSensorsIdYearsRequestPath,
    pub query: SensorYearlyGetV3SensorsSensorsIdYearsRequestQuery,
}
#[bon::bon]
impl SensorYearlyGetV3SensorsSensorsIdYearsRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(
        sensors_id: i64,
        date_to: Option<serde_json::Value>,
        date_from: Option<serde_json::Value>,
        limit: Option<i64>,
        page: Option<i64>,
    ) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorYearlyGetV3SensorsSensorsIdYearsRequestPath { sensors_id },
            query: SensorYearlyGetV3SensorsSensorsIdYearsRequestQuery {
                date_to,
                date_from,
                limit,
                page,
            },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorYearlyGetV3SensorsSensorsIdYearsRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorYearlyGetV3SensorsSensorsIdYearsResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data =
                oas3_gen_support::Diagnostics::<AnnualDataResponse>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorYearlyGetV3SensorsSensorsIdYearsResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorYearlyGetV3SensorsSensorsIdYearsResponse::UnprocessableEntity(data));
        }
        let _ = req.bytes().await?;
        return Ok(SensorYearlyGetV3SensorsSensorsIdYearsResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorYearlyGetV3SensorsSensorsIdYearsRequestPath {
    /// Limit the results to a specific sensors id
    pub sensors_id: i64,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct SensorYearlyGetV3SensorsSensorsIdYearsRequestQuery {
    /// To when?
    pub date_to: Option<serde_json::Value>,
    /// From when?
    pub date_from: Option<serde_json::Value>,
    /// Change the number of results returned.
    ///         e.g. limit=100 will return up to 100 results
    #[default(Some(100i64))]
    pub limit: Option<i64>,
    /// Paginate through results. e.g. page=1 will return first page of results
    #[default(Some(1i64))]
    pub page: Option<i64>,
}
/// Response types for sensor_yearly_get_v3_sensors__sensors_id__years_get
#[derive(Debug, Clone)]
pub enum SensorYearlyGetV3SensorsSensorsIdYearsResponse {
    ///200: Successful Response
    Ok(AnnualDataResponse),
    ///422: Validation Error
    UnprocessableEntity(HTTPValidationError),
    ///default: Unknown response
    Unknown,
}
/// Provides a list of sensors by location ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SensorsGetV3LocationsLocationsIdSensorsRequest {
    pub path: SensorsGetV3LocationsLocationsIdSensorsRequestPath,
}
#[bon::bon]
impl SensorsGetV3LocationsLocationsIdSensorsRequest {
    /// Create a new request with the given parameters.
    #[builder]
    pub fn new(locations_id: i64) -> anyhow::Result<Self> {
        let request = Self {
            path: SensorsGetV3LocationsLocationsIdSensorsRequestPath { locations_id },
        };
        request.validate()?;
        Ok(request)
    }
}
impl SensorsGetV3LocationsLocationsIdSensorsRequest {
    /// Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<SensorGetV3SensorsSensorsIdResponse> {
        let status = req.status();
        if status == http::StatusCode::OK {
            let data = oas3_gen_support::Diagnostics::<SensorsResponse>::json_with_diagnostics(req)
                .await?;
            return Ok(SensorGetV3SensorsSensorsIdResponse::Ok(data));
        }
        if status == http::StatusCode::UNPROCESSABLE_ENTITY {
            let data =
                oas3_gen_support::Diagnostics::<HTTPValidationError>::json_with_diagnostics(req)
                    .await?;
            return Ok(SensorGetV3SensorsSensorsIdResponse::UnprocessableEntity(
                data,
            ));
        }
        let _ = req.bytes().await?;
        return Ok(SensorGetV3SensorsSensorsIdResponse::Unknown);
    }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct SensorsGetV3LocationsLocationsIdSensorsRequestPath {
    /// Limit the results to a specific sensors id
    pub locations_id: i64,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct SensorsResponse {
    pub meta: Option<Meta>,
    pub results: Vec<Sensor>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum SortOrder {
    #[serde(rename = "asc")]
    #[default]
    Asc,
    #[serde(rename = "desc")]
    Desc,
}
impl core::fmt::Display for SortOrder {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Asc => write!(f, "asc"),
            Self::Desc => write!(f, "desc"),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Summary {
    pub avg: Option<f64>,
    pub max: Option<f64>,
    pub median: Option<f64>,
    pub min: Option<f64>,
    pub q02: Option<f64>,
    pub q25: Option<f64>,
    pub q75: Option<f64>,
    pub q98: Option<f64>,
    pub sd: Option<f64>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ValidationError {
    pub loc: Vec<LocKind>,
    pub msg: String,
    #[serde(rename = "type")]
    pub r#type: String,
}
